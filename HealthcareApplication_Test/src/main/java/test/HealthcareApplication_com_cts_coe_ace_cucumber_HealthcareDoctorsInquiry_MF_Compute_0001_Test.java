package test;

import java.io.InputStream;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;

import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.SpyObjectReference;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;

import static com.ibm.integration.test.v1.Matchers.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertArrayEquals;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;


public class HealthcareApplication_com_cts_coe_ace_cucumber_HealthcareDoctorsInquiry_MF_Compute_0001_Test {

	/*
	 * HealthcareApplication_com_cts_coe_ace_cucumber_HealthcareDoctorsInquiry_MF_Compute_0001_Test
	 * Test generated by IBM App Connect Enterprise Toolkit 12.0.7.0 on Feb 13, 2023 5:04:33 PM
	 */
	
	static NodeSpy httpInputSpy;
	static NodeSpy httpReplySpy;
	
	static int scenarioCount;

	@BeforeAll
	public static void setup() throws Exception {
	}

	@AfterAll
	public static void cleanup() throws Exception {
	}

	@AfterEach
	public void cleanupTest() throws TestException {
		// Ensure any mocks created by a test are cleared after the test runs 
		TestSetup.restoreAllMocks();
	}
	
	
	// This is used as one example, using an MXML message file
	static String messageAssemblyName; 

	// This is used for the reply so we can perform checks in the "Then" method.
	// Note that this could cause trouble if not cleaned up and multiple tests
	// are run from the same class.
	static TestMessageAssembly replyMessageAssembly;
	
	
	static TestMessageAssembly replyMessageAssemblyScenario2;
	
	// Set up for the blank body test, using an MXML message file
	@Given("a Specialist Doctor")
	public void a_blank_body() {
		messageAssemblyName = "CardiologistInput";
	}
	
	

	//@Test
	@When("I ask if a particular Specialist Doctor is available")	
	public void HealthcareApplication_com_cts_coe_ace_cucumber_HealthcareDoctorsInquiry_MF_Compute_TestCase_001()
			throws TestException {

		// Define the SpyObjectReference
		//SpyObjectReference nodeReference = new SpyObjectReference().application("HealthcareApplication")
				//.messageFlow("com.cts.coe.ace.cucumber.HealthcareDoctorsInquiry_MF").node("Compute");
		
		SpyObjectReference httpInputObjRef = new SpyObjectReference().application("HealthcareApplication")
				.messageFlow("com.cts.coe.ace.cucumber.HealthcareDoctorsInquiry_MF").node("HTTP Input");
		SpyObjectReference httpReplyObjRef = new SpyObjectReference().application("HealthcareApplication")
				.messageFlow("com.cts.coe.ace.cucumber.HealthcareDoctorsInquiry_MF").node("HTTP Reply");

		// Initialise a NodeSpy
		//NodeSpy nodeSpy = new NodeSpy(nodeReference);
		
		httpInputSpy = new NodeSpy(httpInputObjRef);
		httpReplySpy = new NodeSpy(httpReplyObjRef);

		// Declare a new TestMessageAssembly object for the message being sent into the node
		TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();

		// Create a Message Assembly from the input data file
		try {
			//String messageAssemblyPath = "/com_cts_coe_ace_cucumber_HealthcareDoctorsInquiry_MF_00004C78_63EA1E91_00000001_0.mxml";
			String messageAssemblyPath = "/"+messageAssemblyName+".mxml";
			InputStream messageStream = Thread.currentThread().getContextClassLoader()
					.getResourceAsStream(messageAssemblyPath);
			if (messageStream == null) {
				throw new TestException("Unable to locate message assembly file: " + messageAssemblyPath);
			}
			inputMessageAssembly.buildFromRecordedMessageAssembly(messageStream);
		} catch (Exception ex) {
			throw new TestException("Failed to load input message", ex);
		}

		// Configure the "in" terminal on the HTTP Reply node not to propagate.
		// If we don't do this, then the reply node will throw exceptions when it  
		// realises we haven't actually used the HTTP transport.
		httpReplySpy.setStopAtInputTerminal("in");

		// Now call propagate on the "out" terminal of the HTTP Input node.
		// This takes the place of an actual HTTP message: we simple hand the node
		// the message assembly and tell it to propagate that as if it came from an
		// actual client. This line is where the flow is actually run.
		httpInputSpy.propagate(inputMessageAssembly, "out");
		
		// Validate the results from the flow execution
        // We will now pick up the message that is propagated into the "HttpReply" node and validate it
	    replyMessageAssembly = httpReplySpy.receivedMessageAssembly("in", ++scenarioCount);

		// Compare Output Message 1 at output terminal out

	}
	
	@Then("the results should validate successfully")
	public void the_results_should_validate_successfully() throws TestException 
	{
		TestMessageAssembly expectedMessageAssembly = new TestMessageAssembly();
		try {
			String messageAssemblyPath = "/Kirancardiologist.mxml";
			InputStream messageStream = Thread.currentThread().getContextClassLoader()
					.getResourceAsStream(messageAssemblyPath);
			if (messageStream == null) {
				throw new TestException("Unable to locate message assembly file: " + messageAssemblyPath);
			}
			expectedMessageAssembly.buildFromRecordedMessageAssembly(messageStream);
		} catch (Exception ex) {
			throw new TestException("Failed to load input message", ex);
		}
	    assertThat(replyMessageAssembly, equalsMessage(expectedMessageAssembly).ignoreTimeStamps());
	}
	
	/** Scenario : Fetch and Verify a Specific Doctors Specialization, Address and Phone Number **/
	//@Test
	@When("I ask if Doctor {string} with Specialization as {string}")	
	public void I_ask_if_Doctor_Aravind_with_Specialization_as_Cardiologist(String doctorName, String doctorSpecialization) throws TestException {

		TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();

		try {
			String messageAssemblyPath = "/"+messageAssemblyName+".mxml";
			InputStream messageStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(messageAssemblyPath);
			if (messageStream == null) {
				throw new TestException("Unable to locate message assembly file: " + messageAssemblyPath);
			}
			inputMessageAssembly.buildFromRecordedMessageAssembly(messageStream);
			inputMessageAssembly.messagePath("JSON.Data.Specialization").setValue(doctorSpecialization);
			inputMessageAssembly.messagePath("JSON.Data.Name").setValue(doctorName);
		} catch (Exception ex) {
			throw new TestException("Failed to load input message", ex);
		}
		
		httpReplySpy.setStopAtInputTerminal("in");
		
		httpInputSpy.propagate(inputMessageAssembly, "out");
	    replyMessageAssembly = httpReplySpy.receivedMessageAssembly("in", ++scenarioCount);

	}
	
	@Then("the results should validate successfully with Name as {string}, Specialization as {string}, Address1 as {string} and Phone Number as {string}")
	public void the_results_should_validate_successfully_for_scenario_2(String name, String doctorSpecialization, String address1, String phoneNumber) throws TestException 
	{
		
		String replyName = replyMessageAssembly.messagePath("JSON.Data.Item[0].DoctorFirstName").getValueAsString();
		String replySpecialization = replyMessageAssembly.messagePath("JSON.Data.Item[0].Specialization").getValueAsString();
		String replyAddLine1 = replyMessageAssembly.messagePath("JSON.Data.Item[0].AddLine1").getValueAsString();
		String replyPhoneNumber = replyMessageAssembly.messagePath("JSON.Data.Item[0].PhoneNumber").getValueAsString();
		
		String[] testInputArray = new String[] {name, doctorSpecialization, address1, phoneNumber};
		String[] outputArray = new String[] {replyName, replySpecialization, replyAddLine1, replyPhoneNumber};

		assertArrayEquals(testInputArray, outputArray);
	}

}
